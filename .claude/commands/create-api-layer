#!/bin/bash

# API ë ˆì´ì–´ ìƒì„± ì»¤ë§¨ë“œ (Service + Repository + DTO + Types)
# ì‚¬ìš©ë²•: create-api-layer <name>
# ì˜ˆ: create-api-layer user

set -e

# ìƒ‰ìƒ ì •ì˜
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ì¸ì í™•ì¸
if [ -z "$1" ]; then
  echo -e "${RED}ì˜¤ë¥˜: API ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.${NC}"
  echo "ì‚¬ìš©ë²•: create-api-layer <name>"
  echo "ì˜ˆ: create-api-layer user"
  exit 1
fi

NAME=$1

# ì…ë ¥ ê²€ì¦ (ë³´ì•ˆ: ê²½ë¡œ ì¸ì ì…˜ ë°©ì§€)
if [[ ! "$NAME" =~ ^[a-zA-Z0-9_-]+$ ]]; then
  echo -e "${RED}ì˜¤ë¥˜: ì´ë¦„ì—ëŠ” ì˜ë¬¸ì, ìˆ«ì, í•˜ì´í”ˆ, ì–¸ë”ìŠ¤ì½”ì–´ë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.${NC}"
  exit 1
fi

# ê²½ë¡œ íŠ¸ë˜ë²„ì„¤ ë°©ì§€
if [[ "$NAME" == *".."* ]] || [[ "$NAME" == "/"* ]]; then
  echo -e "${RED}ì˜¤ë¥˜: ìœ íš¨í•˜ì§€ ì•Šì€ ì´ë¦„ì…ë‹ˆë‹¤.${NC}"
  exit 1
fi

# kebab-caseë¡œ ë³€í™˜
KEBAB_NAME=$(echo "$NAME" | sed 's/\([A-Z]\)/-\1/g' | sed 's/^-//' | tr '[:upper:]' '[:lower:]')
# PascalCaseë¡œ ë³€í™˜ (kebab-caseì—ì„œ)
PASCAL_NAME=$(echo "$KEBAB_NAME" | perl -pe 's/(^|-)(.)/\U$2/g')
# camelCaseë¡œ ë³€í™˜ (kebab-caseì—ì„œ)
CAMEL_NAME=$(echo "$KEBAB_NAME" | perl -pe 's/-(.)/\U$1/g')

# íŒŒì¼ ê²½ë¡œ
SERVICE_PATH="src/services/${KEBAB_NAME}.service.ts"
REPOSITORY_PATH="src/repositories/${KEBAB_NAME}.repository.ts"
DTO_PATH="src/dto/${KEBAB_NAME}.dto.ts"
TYPE_PATH="src/types/${KEBAB_NAME}.ts"

# ë””ë ‰í† ë¦¬ ìƒì„±
mkdir -p src/services
mkdir -p src/repositories
mkdir -p src/dto

if [ ! -d "src/types" ]; then
  mkdir -p src/types
fi

# íŒŒì¼ ì¤‘ë³µ í™•ì¸ í•¨ìˆ˜
check_file_exists() {
  if [ -f "$1" ]; then
    echo -e "${YELLOW}ê²½ê³ : $1 íŒŒì¼ì´ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.${NC}"
    read -p "ë®ì–´ì“°ì‹œê² ìŠµë‹ˆê¹Œ? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      echo "ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤."
      exit 0
    fi
  fi
}

# ëª¨ë“  íŒŒì¼ í™•ì¸
check_file_exists "$SERVICE_PATH"
check_file_exists "$REPOSITORY_PATH"
check_file_exists "$DTO_PATH"
check_file_exists "$TYPE_PATH"

# Types íŒŒì¼ ìƒì„±
echo -e "${BLUE}ğŸ“ Types íŒŒì¼ ìƒì„± ì¤‘...${NC}"
cat > "$TYPE_PATH" << EOF
/**
 * ${PASCAL_NAME} íƒ€ì… ì •ì˜
 */

/**
 * ${PASCAL_NAME} ì—”í‹°í‹°
 */
export interface ${PASCAL_NAME} {
  id: string;
  name: string;
  description?: string;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * ${PASCAL_NAME} ëª©ë¡ í•„í„°
 */
export interface ${PASCAL_NAME}Filter {
  search?: string;
  page?: number;
  limit?: number;
}

/**
 * ${PASCAL_NAME} ì •ë ¬ ì˜µì…˜
 */
export type ${PASCAL_NAME}SortBy = 'name' | 'createdAt' | 'updatedAt';

/**
 * ì •ë ¬ ë°©í–¥
 */
export type SortOrder = 'asc' | 'desc';
EOF

echo -e "${GREEN}âœ“ ${TYPE_PATH} ìƒì„± ì™„ë£Œ${NC}"

# DTO íŒŒì¼ ìƒì„±
echo -e "${BLUE}ğŸ“ DTO íŒŒì¼ ìƒì„± ì¤‘...${NC}"
cat > "$DTO_PATH" << EOF
/**
 * ${PASCAL_NAME} Data Transfer Objects
 */

import type { ${PASCAL_NAME} } from '@/types/${KEBAB_NAME}';

/**
 * ${PASCAL_NAME} ìƒì„± DTO
 */
export interface Create${PASCAL_NAME}DTO {
  name: string;
  description?: string;
}

/**
 * ${PASCAL_NAME} ìˆ˜ì • DTO
 */
export interface Update${PASCAL_NAME}DTO {
  name?: string;
  description?: string;
}

/**
 * ${PASCAL_NAME} ì‘ë‹µ DTO
 */
export interface ${PASCAL_NAME}ResponseDTO {
  id: string;
  name: string;
  description?: string;
  createdAt: string;
  updatedAt: string;
}

/**
 * ${PASCAL_NAME} ëª©ë¡ ì‘ë‹µ DTO
 */
export interface ${PASCAL_NAME}ListResponseDTO {
  items: ${PASCAL_NAME}ResponseDTO[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

/**
 * Entityë¥¼ ResponseDTOë¡œ ë³€í™˜
 */
export function to${PASCAL_NAME}ResponseDTO(entity: ${PASCAL_NAME}): ${PASCAL_NAME}ResponseDTO {
  return {
    id: entity.id,
    name: entity.name,
    description: entity.description,
    createdAt: entity.createdAt.toISOString(),
    updatedAt: entity.updatedAt.toISOString(),
  };
}
EOF

echo -e "${GREEN}âœ“ ${DTO_PATH} ìƒì„± ì™„ë£Œ${NC}"

# Repository íŒŒì¼ ìƒì„±
echo -e "${BLUE}ğŸ“ Repository íŒŒì¼ ìƒì„± ì¤‘...${NC}"
cat > "$REPOSITORY_PATH" << EOF
/**
 * ${PASCAL_NAME} Repository
 * ë°ì´í„° ì ‘ê·¼ ë ˆì´ì–´
 */

import type { ${PASCAL_NAME}, ${PASCAL_NAME}Filter } from '@/types/${KEBAB_NAME}';

/**
 * ${PASCAL_NAME} Repository í´ë˜ìŠ¤
 */
export class ${PASCAL_NAME}Repository {
  /**
   * IDë¡œ ${PASCAL_NAME} ì¡°íšŒ
   */
  async findById(id: string): Promise<${PASCAL_NAME} | null> {
    // TODO: ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ ì¡°íšŒ ë¡œì§ êµ¬í˜„
    throw new Error('Not implemented');
  }

  /**
   * ëª¨ë“  ${PASCAL_NAME} ì¡°íšŒ
   */
  async findAll(filter?: ${PASCAL_NAME}Filter): Promise<${PASCAL_NAME}[]> {
    // TODO: ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ ì¡°íšŒ ë¡œì§ êµ¬í˜„
    throw new Error('Not implemented');
  }

  /**
   * ${PASCAL_NAME} ìƒì„±
   */
  async create(data: Omit<${PASCAL_NAME}, 'id' | 'createdAt' | 'updatedAt'>): Promise<${PASCAL_NAME}> {
    // TODO: ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ ìƒì„± ë¡œì§ êµ¬í˜„
    throw new Error('Not implemented');
  }

  /**
   * ${PASCAL_NAME} ìˆ˜ì •
   */
  async update(id: string, data: Partial<${PASCAL_NAME}>): Promise<${PASCAL_NAME}> {
    // TODO: ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ ìˆ˜ì • ë¡œì§ êµ¬í˜„
    throw new Error('Not implemented');
  }

  /**
   * ${PASCAL_NAME} ì‚­ì œ
   */
  async delete(id: string): Promise<void> {
    // TODO: ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ ì‚­ì œ ë¡œì§ êµ¬í˜„
    throw new Error('Not implemented');
  }

  /**
   * ${PASCAL_NAME} ê°œìˆ˜ ì¡°íšŒ
   */
  async count(filter?: ${PASCAL_NAME}Filter): Promise<number> {
    // TODO: ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ ê°œìˆ˜ ì¡°íšŒ ë¡œì§ êµ¬í˜„
    throw new Error('Not implemented');
  }
}

// ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
export const ${CAMEL_NAME}Repository = new ${PASCAL_NAME}Repository();
EOF

echo -e "${GREEN}âœ“ ${REPOSITORY_PATH} ìƒì„± ì™„ë£Œ${NC}"

# Service íŒŒì¼ ìƒì„±
echo -e "${BLUE}ğŸ“ Service íŒŒì¼ ìƒì„± ì¤‘...${NC}"
cat > "$SERVICE_PATH" << EOF
/**
 * ${PASCAL_NAME} Service
 * ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë ˆì´ì–´
 */

import { ${CAMEL_NAME}Repository } from '@/repositories/${KEBAB_NAME}.repository';
import type {
  Create${PASCAL_NAME}DTO,
  Update${PASCAL_NAME}DTO,
  ${PASCAL_NAME}ResponseDTO,
  ${PASCAL_NAME}ListResponseDTO,
} from '@/dto/${KEBAB_NAME}.dto';
import { to${PASCAL_NAME}ResponseDTO } from '@/dto/${KEBAB_NAME}.dto';
import type { ${PASCAL_NAME}Filter } from '@/types/${KEBAB_NAME}';

/**
 * ${PASCAL_NAME} Service í´ë˜ìŠ¤
 */
export class ${PASCAL_NAME}Service {
  /**
   * IDë¡œ ${PASCAL_NAME} ì¡°íšŒ
   */
  async get${PASCAL_NAME}ById(id: string): Promise<${PASCAL_NAME}ResponseDTO> {
    const ${NAME} = await ${CAMEL_NAME}Repository.findById(id);

    if (!${NAME}) {
      throw new Error('${PASCAL_NAME}ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }

    return to${PASCAL_NAME}ResponseDTO(${NAME});
  }

  /**
   * ${PASCAL_NAME} ëª©ë¡ ì¡°íšŒ
   */
  async get${PASCAL_NAME}List(
    filter?: ${PASCAL_NAME}Filter
  ): Promise<${PASCAL_NAME}ListResponseDTO> {
    const page = filter?.page || 1;
    const limit = filter?.limit || 10;

    const [items, total] = await Promise.all([
      ${CAMEL_NAME}Repository.findAll(filter),
      ${CAMEL_NAME}Repository.count(filter),
    ]);

    const totalPages = Math.ceil(total / limit);

    return {
      items: items.map(to${PASCAL_NAME}ResponseDTO),
      total,
      page,
      limit,
      totalPages,
    };
  }

  /**
   * ${PASCAL_NAME} ìƒì„±
   */
  async create${PASCAL_NAME}(data: Create${PASCAL_NAME}DTO): Promise<${PASCAL_NAME}ResponseDTO> {
    // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ê²€ì¦
    if (!data.name || data.name.trim() === '') {
      throw new Error('ì´ë¦„ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.');
    }

    const ${NAME} = await ${CAMEL_NAME}Repository.create(data);
    return to${PASCAL_NAME}ResponseDTO(${NAME});
  }

  /**
   * ${PASCAL_NAME} ìˆ˜ì •
   */
  async update${PASCAL_NAME}(
    id: string,
    data: Update${PASCAL_NAME}DTO
  ): Promise<${PASCAL_NAME}ResponseDTO> {
    // ì¡´ì¬ ì—¬ë¶€ í™•ì¸
    const existing = await ${CAMEL_NAME}Repository.findById(id);
    if (!existing) {
      throw new Error('${PASCAL_NAME}ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }

    // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ê²€ì¦
    if (data.name !== undefined && data.name.trim() === '') {
      throw new Error('ì´ë¦„ì€ ë¹„ì–´ìˆì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }

    const updated = await ${CAMEL_NAME}Repository.update(id, data);
    return to${PASCAL_NAME}ResponseDTO(updated);
  }

  /**
   * ${PASCAL_NAME} ì‚­ì œ
   */
  async delete${PASCAL_NAME}(id: string): Promise<void> {
    // ì¡´ì¬ ì—¬ë¶€ í™•ì¸
    const existing = await ${CAMEL_NAME}Repository.findById(id);
    if (!existing) {
      throw new Error('${PASCAL_NAME}ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }

    await ${CAMEL_NAME}Repository.delete(id);
  }
}

// ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
export const ${CAMEL_NAME}Service = new ${PASCAL_NAME}Service();
EOF

echo -e "${GREEN}âœ“ ${SERVICE_PATH} ìƒì„± ì™„ë£Œ${NC}"

# ì™„ë£Œ ë©”ì‹œì§€
echo ""
echo -e "${GREEN}ğŸ‰ API ë ˆì´ì–´ ìƒì„±ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!${NC}"
echo ""
echo "ìƒì„±ëœ íŒŒì¼:"
echo "  â€¢ $TYPE_PATH"
echo "  â€¢ $DTO_PATH"
echo "  â€¢ $REPOSITORY_PATH"
echo "  â€¢ $SERVICE_PATH"
echo ""
echo "ì•„í‚¤í…ì²˜:"
echo "  Controller (API Routes) â†’ Service â†’ Repository â†’ Database"
echo ""
echo "ë‹¤ìŒ ë‹¨ê³„:"
echo "  1. ${TYPE_PATH}ì—ì„œ íƒ€ì…ì„ ìˆ˜ì •í•˜ì„¸ìš”"
echo "  2. ${DTO_PATH}ì—ì„œ DTOë¥¼ ìˆ˜ì •í•˜ì„¸ìš”"
echo "  3. ${REPOSITORY_PATH}ì—ì„œ ë°ì´í„° ì ‘ê·¼ ë¡œì§ì„ êµ¬í˜„í•˜ì„¸ìš”"
echo "  4. ${SERVICE_PATH}ì—ì„œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ êµ¬í˜„í•˜ì„¸ìš”"
echo "  5. API ë¼ìš°íŠ¸ì—ì„œ ${NAME}Serviceë¥¼ ì‚¬ìš©í•˜ì„¸ìš”"
